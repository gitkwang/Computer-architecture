1. 분리형 곱

Multiplier (곱하는수)의 LSB 검사
1이면 초기 product 0에 그대로 더한다. 이후 multiplicand를 left shift >> 왜? 그래야 계산이 계단식으로 차곡차곡 더해진다. 

0이면 그대로

이후 multiplier( 곱하는수) 를 right shift . 한자리씩 처리하고 오른쪽으로 옮겨서 없애버리기
즉 shift는 multiplier의 비트수-1 번 이뤄지겠죠? 비트수만큼 이뤄지면 0000이 된다고 생각해도 무방

그리고 나머지를 다 더하면 곱한 값이 나온다!. 

마지막으로 64bit ALU기 때문에 최대 32bit* 32bit 계산까지 가능>> 곱하면 2*32bit 숫자가 나오기땜


2. 결합형 곱

초기 product를 product의 하위 4비트를 mulitplier로 채운다(곱하는수로)
ex) 1000 * 1001 이면 초기 product = 00001001

(1) product의 LSB 검사 > 1이면 multiplicand (곱해지는 원래수)를 상위 4bit로 채운다. 더한다
(2) LSB=0이면 그대로 둔다
(3) 이후 product를 1 right shift 한다.

이것또한 multiplier의 bit수만큼 shift가 일어난다

ex) 1000*1001 >> 과정 8*9 구하기

0000 1001> M+ 1000 1001> shift 01000100> shift 00100010>shift 00010001> M+ 10010001> shfit 01001000 = 72


3. Long division


상위 4비트 비교.
1. Remain < divisior 이면 몫 0 처리 > negative니까 restore> 몫 shift left> divisior shift right
   Remain >=divisor이면 > 몫 1 처리 >몫 shift left> divisor shift right
